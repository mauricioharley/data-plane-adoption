[id="tls-everywhere_{context}"]

//:context: tls

//kgilliga: This module will be converted to an assembly. Check xref contexts.

= TLS Everywhere

_Disclaimer: the below steps were reproduced on a FreeIPA 4.10.1 server. The location of files and directories may slightly change on different versions._

== Prerequisites

* Check that the source deployment is using TLS Everywhere, skip this step if it's not.
* Make sure the previous Adoption steps have been performed successfully.
* Make sure the backend services on the new deployment are not started yet.

== Variables

Define the shell variables used in the following steps. The values are illustrative and refer to a single node standalone director deployment. Use values that are correct for your environment:

----
IPA_SSH="ssh -i ~/install_yamls/out/edpm/ansibleee-ssh-key-id_rsa root@<freeipa-server-ip-address>"
----

In this example the FreeIPA instance is running on a separate host, in a container.

== Transfer the CA certificate and key from FreeIPA to the cert-manager Operator

This is only going to work if:

1. The CA that is used for TLS-e in the source environment (Red Hat OpenStack 16 or 17) is not used for anything else. In such case, it may be advisable not to extract the CA certificate. It is the expected that this CA will be decommissioned afterwards, and the new cert-manager CA will be used instead.
2. The IPA CA stores its certficates in NSSDB. Otherwise, if the certificate is stored in an HSM (Hardware Security Module), for instance, the key may not be retrievable. Or if it is retrievable, special HSM utilities may be required.

=== Exporting from FreeIPA

You will need to interact with the database located in the `/etc/pki/pki-tomcat/alias` directory ("*db" files).

==== Locating the CA certificate and key

List all the certificates inside your NSSDB:

----
$ $IPA_SSH certutil -L -d /etc/pki/pki-tomcat/alias
----

The `-L` option lists all certificates, and `-d` specifies where they are stored. This will produce some output like this:

----
Certificate Nickname                                         Trust Attributes
                                                             SSL,S/MIME,JAR/XPI

caSigningCert cert-pki-ca                                    CTu,Cu,Cu
ocspSigningCert cert-pki-ca                                  u,u,u
Server-Cert cert-pki-ca                                      u,u,u
subsystemCert cert-pki-ca                                    u,u,u
auditSigningCert cert-pki-ca                                 u,u,Pu
----

The item you need to consider is the first one: `caSigningCert cert-pki-ca`.

==== Exporting the items (certificate and key)

The command below generates a P12 file with both, the certificate and the key. The `/etc/pki/pki-tomcat/alias/pwdfile.txt` file contains the password that protects the key. You can use it to both, extract the key and generate the new file, `/tmp/freeipa.p12`. You can also choose another password. Should you choose to apply a different password for the new file, simply replace the parameter of the `-w` option, or alternatively use the `-W` (capital W) option followed by the password (in clear text).

----
$IPA_SSH pk12util -o /tmp/freeipa.p12 -n 'caSigningCert\ cert-pki-ca' -d /etc/pki/pki-tomcat/alias -k /etc/pki/pki-tomcat/alias/pwdfile.txt -w /etc/pki/pki-tomcat/alias/pwdfile.txt
----

With that file on hand, we can separately get the certificate and the key, using the openssl pkcs12 command.

The key length is another important property. You will need it below, when crafting one of the YAML files that will be used to provision the new custom resources. You can get it with:

----
KEY_LENGTH=`$IPA_SSH openssl pkcs12 -in /tmp/freeipa.p12 -passin file:/etc/pki/pki-tomcat/alias/pwdfile.txt -nocerts -noenc | openssl rsa -text -noout | awk -F'[^0-9]+' '{ print $2; exit }'`
----

==== Importing the Items and Provisioning the Custom Resources (CRs) on OpenShift

You will have to create two YAML files. The first one has three sections:

* The `openstack` namespace, which is used by other Red Hat OpenStack operators and CRs.
* The issuer. The cert-manager operator makes use of a self-signed issuer to issue both the CA certificate itself and other certificates.
* The CA certificate itself. We are specifically naming it as `rootca-internal`, which corresponds to the certificate authority leveraged by cert-manager to issue other certificates.

Let's apply the following YAML file to create the corresponding CRs:

[source,yaml]
----
oc apply -f - <<EOF
apiVersion: v1
kind: Namespace
metadata:
  name: openstack
---
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: selfsigned-issuer
  namespace: openstack
spec:
  selfSigned: {}
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: rootca-internal
  namespace: openstack
spec:
  isCA: true
  commonName: rootca-internal
  secretName: rootca-internal
  privateKey:
    algorithm: RSA
    size: $KEY_LENGTH
  issuerRef:
    name: selfsigned-issuer
EOF
----


OK, you just created the CRs with the initial content. Now you will need to import the certificate and the key that you exported from FreeIPA. You can do this with the `oc patch` command. For the CA certificate (correspondeing to the `ca.crt` item on the Certificate, type:

----
oc patch secret rootca-internal -n openstack -p="{\"data\":{\"ca.crt\": \"`$IPA_SSH openssl pkcs12 -in /tmp/freeipa.p12 -passin file:/etc/pki/pki-tomcat/alias/pwdfile.txt -nokeys | openssl x509 | base64 -w 0`\"}}"
----

You will also need to update the `tls.crt` item. For the CA, this will receive the very same contents of `ca.crt`. The command just needs a small adjustment:

----
oc patch secret rootca-internal -n openstack -p="{\"data\":{\"tls.crt\": \"`$IPA_SSH openssl pkcs12 -in /tmp/freeipa.p12 -passin file:/etc/pki/pki-tomcat/alias/pwdfile.txt -nokeys | openssl x509 | base64 -w 0`\"}}"
----

Finally, update the key:

----
oc patch secret rootca-internal -n openstack -p="{\"data\":{\"tls.key\": \"`$IPA_SSH openssl pkcs12 -in /tmp/freeipa.p12 -passin file:/etc/pki/pki-tomcat/alias/pwdfile.txt -nocerts -noenc | openssl rsa | base64 -w 0`\"}}"
----

Now create the cert-manager Issuer, referencing the created secret:

[source, yaml]
----
oc apply -f - <<EOF
apiVersion: v1
kind: Namespace
metadata:
  name: openstack
---
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: rootca-internal
  namespace: openstack
  labels:
    osp-rootca-issuer-internal: ""
spec:
  ca:
    secretName: rootca-internal
EOF
----

*Note: Do note forget to delete the p12 files you created during the previous steps, like `/tmp/freeipa.p12`!*

==== Checking the newly provisioned CRs

You can check the created resources with the commands below:

----
oc get issuers -n openstack
----

----
oc get secret rootca-internal -n openstack -o yaml
----

== Stop and disable certmonger, and remove the existing certificates

The final step on this activity is to stop and disable the certmonger service on all EDPM nodes, and stop tracking all certificates managed by it. The code below accomplishes this task:

[source, bash]
----
#!/bin/bash

for i in "${!computes[@]}"; do
    SSH_CMD="ssh -i $EDPM_PRIVATEKEY_PATH root@${computes[$i]}"
    if ${SSH_CMD} sudo systemctl is-active certmonger.service; then
        echo "Stopping certmonger on $i..."
        ${SSH_CMD} sudo systemctl stop certmonger.service
        echo "Disabling certmonger on $i..."
        ${SSH_CMD} sudo systemctl disable --now certmonger.service
        ${SSH_CMD} test -f /etc/systemd/system/certmonger.service '||' sudo systemctl mask certmonger.service
    fi

    # If necessary, adjust the directory below accordingly.
    certs_directory=/var/lib/certmonger/requests
    certs_to_stop=$(${SSH_CMD} ls -1 $certs_directory)
    number_of_certs=$(${SSH_CMD} ls -1 $certs_directory | wc -l)

    if [ $? != 0 ] || [ $number_of_certs = 0 ]; then
        echo "No certificates to stop tracking on $i."
    else
        echo "There is/are $number_of_certs certificates to stop being tracked on $i. Stopping to track certificates..."
    fi

    while IFS= read -r cert; do
        echo "Stopping to track $cert..."
        ${SSH_CMD} rm -f $certs_directory/$cert
    done <<< "$certs_to_stop"
done
----

